<!DOCTYPE html>
<html>
<head>
  <title>Image Processor</title>
  <link rel="stylesheet" href="static/style/style.css?v=2">
  <link rel="stylesheet" href="static/style/gamma.css?v=2">
  <link rel="stylesheet" href="static/style/messages.css?v=2">
</head>
<body>

  <div class="main-container">

    <div class="nav-cont">
        <button onclick="BW()">BW</button>
        <button onclick="removeBG()">Remove BG</button>
        <button onclick="gammaF()">Gamma</button>
        <button onclick="drawCurve()">Curve</button>
    </div>

    <div class="window-cont">

      <div class="h-nav">
        <input type="file" id="fileInput" accept=".jpg, .JPG, .jpeg, .png, .cr2, .nef, .arw, .dng, .rw2">
        <button onclick="location.reload()">Reload App</button>
      </div>

      <div class="desctop">
        <p id="load">Processing...</p>
        <p id="dialogWindow"></p>

        <!-- <canvas id="imageCanvas" style="display:none;"></canvas> -->
        <canvas id="previewCanvas" style="display:none;" width="1000" height="1000"></canvas>
        <canvas id="fullCanvas" style="display:none;"></canvas>

        <div id="workspace">

          <img id="original" style="display: none;">
          <img id="res">

          <div id="gammaCont">

              <canvas id="curveCanvas" width="300" height="300" style="display:block; border:1px solid #ffffff;"></canvas>

              <p id="gammaVal">Brightness</p>
              <input type="range" id="gammaSlider" min="0" max="300" step="10" value="100">

              <p id="exposureVal">Exposure</p>
              <input type="range" id="exposureSlider" min="-10" max="10" step="1" value="0">

              <p id="shadowVal">Shadows</p>
              <input type="range" id="shadowSlider" min="-10" max="10" step="1" value="0">

              <p id="lightVal">Lights</p>
              <input type="range" id="lightSlider" min="-10" max="10" step="1" value="0">

              <p>Red</p>
              <input type="range" id="redSlider" min="-10" max="10" step="0.1" value="1">

              <p>Green</p>
              <input type="range" id="greenSlider" min="-10" max="10" step="0.1" value="1">

              <p>Blue</p>
              <input type="range" id="blueSlider" min="-10" max="10" step="0.1" value="1">

              <p>Shadows Tint (Green ↔ Magenta)</p>
              <input type="range" id="shadowsTint" min="-10" max="10" step="1" value="0"><br>

              <p>Red Primary Hue</p>
              <input type="range" id="redHue" min="-1" max="1" step="0.01" value="0"><br>
              <p>Red Primary Saturation</p>
              <input type="range" id="redSat" min="0" max="2" step="0.01" value="1"><br>

              <p>Green Primary Hue</p>
              <input type="range" id="greenHue" min="-1" max="1" step="0.01" value="0"><br>
              <p>Green Primary Saturation</p>
              <input type="range" id="greenSat" min="0" max="2" step="0.01" value="1"><br>

              <p>Blue Primary Hue</p>
              <input type="range" id="blueHue" min="-1" max="1" step="0.01" value="0"><br>
              <p>Blue Primary Saturation</p>
              <input type="range" id="blueSat" min="0" max="2" step="0.01" value="1"><br>

          </div>

        </div>


      </div>

    </div>

  </div>

  <script>

    let base64Image = '';
    let image = document.getElementById('original')
    let res = document.getElementById('res')
    let load = document.getElementById('load')
    // const canvas       = document.getElementById("imageCanvas");
    // const ctx          = canvas.getContext("2d");
    const previewCanvas       = document.getElementById("previewCanvas");
    const previewCtx          = previewCanvas.getContext("2d");
    const fullCanvas       = document.getElementById("fullCanvas");
    const fullCtx          = fullCanvas.getContext("2d");
    const gammaCont = document.getElementById("gammaCont");

    const dialogWindow = document.getElementById('dialogWindow');


    // CHOOSE THE IMAGE
    // document.getElementById('fileInput').addEventListener('change', function (e) {
    //   const reader = new FileReader();
    //   reader.onload = function () {
    //     base64Image = reader.result;
    //     image.src = base64Image;
    //   };
    //   reader.readAsDataURL(e.target.files[0]);
    // });


    window.addEventListener('pywebviewready', () => {
      const image = document.getElementById('original');
      const fileInput = document.getElementById('fileInput');
      drawCurve()

      fileInput.addEventListener('change', async () => {
        dialogWindow.style.display = 'block';
        const file = fileInput.files[0];
        console.log('---------Filename----------', file.name);
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();
        const base64 = await arrayBufferToBase64(arrayBuffer);
        try {
          dialogWindow.innerText = `${file.name} is loading...`;
          const previewDataUrl = await window.pywebview.api.load_image_from_base64(base64, file.name);
          image.src = previewDataUrl;
          base64Image = previewDataUrl;
          dialogWindow.style.display = 'none';
        } catch (err) {
          dialogWindow.innerText = `Error ${err}`;
        }
      });

      function arrayBufferToBase64(buffer) {
        return new Promise((resolve, reject) => {
          const blob = new Blob([buffer], { type: 'application/octet-stream' });
          const reader = new FileReader();

          reader.onloadend = () => {
            const base64 = reader.result.split(',')[1]; // remove `data:...;base64,`
            resolve(base64);
          };

          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

  });



    // Black and white
    async function BW() {
      if (!base64Image) return alert("Please select an image first.");

      const result = await window.pywebview.api.process_image(base64Image);
      load.style.display = 'block';
      if (result.status === "success") {
        image.src = result.output_path + '?' + new Date().getTime(); // cache busting
        imgElem.src = result.output_path + '?' + new Date().getTime(); // cache copy busting
        load.style.display = 'none';
      } else {
        alert("Error: " + result.message);
        load.style.display = 'none';
      }
    }



    // REMOVE BACKGROUND
    async function removeBG() {
      if (!base64Image) return alert("Please select an image first.");

      const result = await window.pywebview.api.remove_bg(base64Image);
      if (result.status === "success") {
        image.src = result.output_path + '?' + new Date().getTime(); // cache busting
      } else {
        alert("Error: " + result.message);
      }
    }

    const gammaSlider = document.getElementById("gammaSlider");

    // MANIPULATE WITH THE BRIGHTNESS
    // function gammaF() {   

    //   if (gammaCont.style.display === 'none') {
    //     gammaCont.style.display = 'block';
    //   } else {
    //     gammaCont.style.display = 'none';
    //   }
    // }

    gammaSlider.addEventListener("input", () => {
      applyGammaCorrection(parseFloat(gammaSlider.value));
    });

    function applyGammaCorrection(gamma) {
      if (!image.src) return;
      res.style.filter = `brightness(${gamma}%)`;
    }


    const exposureSlider = document.getElementById("exposureSlider");
    const shadowSlider = document.getElementById("shadowSlider");
    const lightSlider  = document.getElementById("lightSlider");
    const redSlider = document.getElementById("redSlider");
    const greenSlider = document.getElementById("greenSlider");
    const blueSlider = document.getElementById("blueSlider");
    const shadowsTint = document.getElementById("shadowsTint");
    const redHue = document.getElementById("redHue");
    const redSat = document.getElementById("redSat");
    const greenHue = document.getElementById("greenHue");
    const greenSat = document.getElementById("greenSat");
    const blueHue = document.getElementById("blueHue");
    const blueSat = document.getElementById("blueSat");


    let originalImage = null; //new Image();
    let previewImage = null;

    image.onload = () => {
      // Full-size canvas
      fullCanvas.width = image.naturalWidth;
      fullCanvas.height = image.naturalHeight;
      fullCtx.drawImage(image, 0, 0);

      originalImage = fullCtx.getImageData(0, 0, fullCanvas.width, fullCanvas.height);

      // Downscale for preview
      const previewSize = 1000;
      const scale = Math.min(previewSize / image.naturalWidth, previewSize / image.naturalHeight);

      previewCanvas.width = image.naturalWidth * scale;
      previewCanvas.height = image.naturalHeight * scale;

      previewCtx.drawImage(image, 0, 0, previewCanvas.width, previewCanvas.height);
      previewImage = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

      // Draw initial preview
      applyChanges(0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1); // Default
    };


    // sRGB (0–1) to Linear RGB
    function sRGBToLinear(c) {
      c = c / 255;
      return (c <= 0.04045) ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }

    // Linear RGB to sRGB (0–1)
    function linearToSRGB(c) {
      return (c <= 0.0031308) ?
        12.92 * c :
        1.055 * Math.pow(c, 1 / 2.4) - 0.055;
    }


    let shadowStrength;
    let lightStrength;
    let exposureStrength;
    let r;
    let g;
    let b;
    let shadowsTintStrenth;
    let redHueStrenth;
    let redSatStrength;
    let greenHueStrenth;
    let greenSatStrength;
    let blueHueStrenth;
    let blueSatStrength;
    let lut;


    [
      exposureSlider, 
      shadowSlider, 
      lightSlider, 
      redSlider, 
      greenSlider, 
      blueSlider,
      shadowsTint, 
      redHue, 
      redSat,
      greenHue, 
      greenSat, 
      blueHue, 
      blueSat
    ].forEach(slider => {
      slider.addEventListener("input", () => {
        shadowStrength = parseFloat(shadowSlider.value);
        lightStrength = parseFloat(lightSlider.value);
        exposureStrength = parseFloat(exposureSlider.value);
        r = parseFloat(redSlider.value);
        g = parseFloat(greenSlider.value);
        b = parseFloat(blueSlider.value);
        shadowsTintStrenth = parseFloat(shadowsTint.value);
        redHueStrenth = parseFloat(redHue.value);
        redSatStrength = parseFloat(redSat.value);
        greenHueStrenth = parseFloat(greenHue.value);
        greenSatStrength = parseFloat(greenSat.value);
        blueHueStrenth = parseFloat(blueHue.value); 
        blueSatStrength = parseFloat(blueSat.value);
        applyChanges(
          exposureStrength, 
          shadowStrength, 
          lightStrength, 
          r,
          g,
          b,
          shadowsTintStrenth, 
          redHueStrenth, 
          redSatStrength,
          greenHueStrenth, 
          greenSatStrength, 
          blueHueStrenth, 
          blueSatStrength,
          // lut,
        )
      });
    });


    function applyChanges(
      exposureStrength, 
      shadowStrength, 
      lightStrength, 
      redShift,
      greenShift,
      blueShift,
      shadowsTintStrength, 
      redHueStrength, 
      redSatStrength,
      greenHueStrength, 
      greenSatStrength, 
      blueHueStrength, 
      blueSatStrength,
      // lut,
    ) {
      if (!previewImage) return;

      console.log('lut--------------', lut)

      if (!lut) {
        lut = Array.from({ length: 256 }, (_, i) => i);  // ✅ use identity LUT if missing
        console.log('!lut--------------', lut)
      }

      const imageData = new ImageData(
        new Uint8ClampedArray(previewImage.data),
        previewImage.width,
        previewImage.height
      );

      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i];
        let g = data[i + 1];
        let b = data[i + 2];

        // === CURVE LUT
        data[i]     = lut[data[i]];     // R
        data[i + 1] = lut[data[i + 1]]; // G
        data[i + 2] = lut[data[i + 2]]; // B

        // Luma approximation (brightness)
        let brightness = 0.299 * r + 0.587 * g + 0.114 * b;

        // Exposure factor: commonly 2^EV (Exposure Value)
        const exposureFactor = Math.pow(2, exposureStrength); // e.g., EV +1 = 2x brighter
        // Convert to linear
        let lr = sRGBToLinear(r);
        let lg = sRGBToLinear(g);
        let lb = sRGBToLinear(b);

        // Apply exposure in linear space
        lr *= exposureFactor;
        lg *= exposureFactor;
        lb *= exposureFactor;


        // data[i]     = Math.min(255, r * exposureFactor);
        // data[i + 1] = Math.min(255, g * exposureFactor);
        // data[i + 2] = Math.min(255, b * exposureFactor);

        data[i]     = Math.min(255, r * redShift);
        data[i + 1] = Math.min(255, g * greenShift);
        data[i + 2] = Math.min(255, b * blueShift);

        if (brightness < 100) {
          const factor = 1 + shadowStrength * (1 - brightness / 100);
          data[i]     = Math.min(255, r * factor);
          data[i + 1] = Math.min(255, g * factor);
          data[i + 2] = Math.min(255, b * factor);
        }

        if (brightness > 155) {
          const factor = 1 + lightStrength  * ((brightness - 155) / 100);
          data[i]  = Math.min(255, Math.max(0, r * factor));
          data[i + 1] = Math.min(255, Math.max(0, g * factor));
          data[i + 2] = Math.min(255, Math.max(0, b * factor)); 
        }

        // === Shadows Tint (Green ↔ Magenta)
        data[i]     = Math.min(255, g * (1 + shadowsTintStrength));
        data[i + 1] = Math.min(255, r * (1 - shadowsTintStrength / 2));
        data[i + 2] = Math.min(255, b * (1 - shadowsTintStrength / 2));
        // if (brightness < 100) {
        //   lg = lg * (1 + shadowsTintStrength);
        //   lr = lr * (1 - shadowsTintStrength / 2);
        //   lb = lb * (1 - shadowsTintStrength / 2);
        // }

        // === Red Primary Hue + Sat (affects reds more)
        // if (r > g && r > b) {
          r += redHueStrength * (g - b);
          r *= redSatStrength;
        // }

        // === Green Primary Hue + Sat (affects greens more)
        // if (g > r && g > b) {
          g += greenHueStrength * (b - r);
          g *= greenSatStrength;
        // }

        // === Blue Primary Hue + Sat (affects blues more)
        // if (b > r && b > g) {
          b += blueHueStrength * (r - g);
          b *= blueSatStrength;
        // }

        data[i] = Math.min(255, Math.max(0, r));
        data[i + 1] = Math.min(255, Math.max(0, g));
        data[i + 2] = Math.min(255, Math.max(0, b));
        // Convert back to sRGB
        // data[i]     = Math.min(255, linearToSRGB(lr) * 255);
        // data[i + 1] = Math.min(255, linearToSRGB(lg) * 255);
        // data[i + 2] = Math.min(255, linearToSRGB(lb) * 255);

      }

      previewCtx.putImageData(imageData, 0, 0);
      res.src = previewCanvas.toDataURL();
    }



    let isDragging = false;
    let offsetX, offsetY;


    gammaCont.addEventListener("mousedown", (e) => {
        if (e.target.tagName === "INPUT") return;
        isDragging = true;
        offsetX = e.clientX - gammaCont.getBoundingClientRect().left;
        offsetY = e.clientY - gammaCont.getBoundingClientRect().top;
        gammaCont.style.cursor = "grabbing";
    });

    document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;

        gammaCont.style.left = `${e.clientX - offsetX}px`;
        gammaCont.style.top = `${e.clientY - offsetY}px`;
    });

    document.addEventListener("mouseup", () => {
        isDragging = false;
        gammaCont.style.cursor = "grab";
    });


    // CURVE LOGIC
    let curvePoints = [
    { x: 0, y: 0 },
    { x: 64, y: 64 },
    { x: 128, y: 128 },
    { x: 192, y: 192 },
    { x: 255, y: 255 }
  ];

  function getCurveLUT(points) {
    lut = new Uint8ClampedArray(256);
    for (let i = 0; i < 256; i++) {
      lut[i] = applyCurve(i, points);
    }
    return lut;
  }

  function applyCurve(value, points) {
    // Linear interpolation between points
    for (let i = 0; i < points.length - 1; i++) {
      const p1 = points[i];
      const p2 = points[i + 1];
      if (value >= p1.x && value <= p2.x) {
        const ratio = (value - p1.x) / (p2.x - p1.x);
        return Math.round(p1.y + ratio * (p2.y - p1.y));
      }
    }
    return value; // fallback
  }

  const canvas = document.getElementById("curveCanvas");
  const ctx = canvas.getContext("2d");
  const pointRadius = 5;

  // canvas.addEventListener("mousedown", onMouseDown);
  canvas.addEventListener("mousedown", e => {
    e.stopPropagation();  // ✅ prevent canvas toggle behavior
    onMouseDown(e);
  });
  canvas.addEventListener("mousemove", e => {
    if (dragging !== null) {
      onMouseMove(e);  // this should update the curve + image only when dragging
    }
  });


  // canvas.addEventListener("mousemove", onMouseMove);
  canvas.addEventListener("mouseup", () => dragging = null);
  canvas.addEventListener("mouseleave", () => dragging = null);

  let dragging = null;

  function drawCurve() {
    // canvas.style.display = canvas.style.display === "block" ? "none" : "block";
    canvas.style.cursor = "crosshair";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "white";
    ctx.beginPath();
    for (let i = 0; i < curvePoints.length; i++) {
      const p = curvePoints[i];
      const px = p.x * canvas.width / 255;
      const py = canvas.height - p.y * canvas.height / 255;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Draw points
    curvePoints.forEach((p, i) => {
      const px = p.x * canvas.width / 255;
      const py = canvas.height - p.y * canvas.height / 255;
      ctx.beginPath();
      ctx.arc(px, py, pointRadius, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
    });
  }

  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  function onMouseDown(e) {
    const pos = getMousePos(e);
    const cx = pos.x * 255 / canvas.width;
    const cy = (canvas.height - pos.y) * 255 / canvas.height;

    for (let i = 0; i < curvePoints.length; i++) {
      const p = curvePoints[i];
      const px = p.x * canvas.width / 255;
      const py = canvas.height - p.y * canvas.height / 255;
      const dx = pos.x - px;
      const dy = pos.y - py;
      if (dx * dx + dy * dy < pointRadius * pointRadius * 4) {
        dragging = i;
        break;
      }
    }
  }

  function onMouseMove(e) {
    if (dragging === null) return;
    const pos = getMousePos(e);
    const x = Math.max(0, Math.min(255, pos.x * 255 / canvas.width));
    const y = Math.max(0, Math.min(255, (canvas.height - pos.y) * 255 / canvas.height));

    curvePoints[dragging].x = x;
    curvePoints[dragging].y = y;

    curvePoints.sort((a, b) => a.x - b.x); // Maintain order
    drawCurve();
    lut = getCurveLUT(curvePoints);
    console.log('onMouseMove----------', lut)
    if (lut !== 'undefined') {
      applyChanges(
      exposureStrength, 
      shadowStrength, 
      lightStrength, 
      redShift,
      greenShift,
      blueShift,
      shadowsTintStrength, 
      redHueStrength, 
      redSatStrength,
      greenHueStrength, 
      greenSatStrength, 
      blueHueStrength, 
      blueSatStrength,
      // lut,
    ) 
    }
    // applyToneCurveToImage(lut);
    
  };


  function applyToneCurveToImage(lut) {
    if (!previewImage) return;

    console.log('applyToneCurveToImage', lut)

    const imageData = new ImageData(
      new Uint8ClampedArray(previewImage.data),
      previewImage.width,
      previewImage.height
    );

    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
      data[i]     = lut[data[i]];     // R
      data[i + 1] = lut[data[i + 1]]; // G
      data[i + 2] = lut[data[i + 2]]; // B
    }

    previewCtx.putImageData(imageData, 0, 0);
    res.src = previewCanvas.toDataURL();
  }






  </script>
  <script src="./js/gamma.js"></script>
</body>
</html>
