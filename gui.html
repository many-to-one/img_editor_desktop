<!DOCTYPE html>
<html>
<head>
  <title>Image Processor</title>
  <link rel="stylesheet" href="static/style/style.css?v=2">
  <link rel="stylesheet" href="static/style/gamma.css?v=2">
  <link rel="stylesheet" href="static/style/messages.css?v=2">
</head>
<body>

  <div class="main-container">

    <div class="nav-cont">
        <button onclick="BW()">BW</button>
        <button onclick="removeBG()">Remove BG</button>
        <button onclick="gammaF()">Gamma</button>
        
    </div>

    <div class="window-cont">

      <div class="h-nav">
        <input type="file" id="fileInput" accept=".jpg, .JPG, .jpeg, .png, .cr2, .nef, .arw, .dng, .rw2">
        <button onclick="location.reload()">Reload App</button>
      </div>

      <div class="desctop">
        <p id="load">Processing...</p>
        <p id="dialogWindow"></p>

        <canvas id="previewCanvas" style="display:none;" width="1000" height="1000"></canvas>
        <canvas id="fullCanvas" style="display:none;"></canvas>

        <div id="workspace">

          <img id="original" style="display: none;">
          <img id="res">

          <div id="gammaCont">

              <!-- <button onclick="drawCurve()">Curve</button> -->
              <div id="curveCont">
                <canvas id="curveCanvas" width="300" height="300" style="display:block; border:1px solid #ffffff;"></canvas>
              </div>
              <hr>

              <div id="tone">
                <h4>Tone</h4>
                <div id="editCont">
                  <p id="gammaVal">Brightness</p>
                  <input type="range" id="gammaSlider" class="sliders" min="0" max="300" step="10" value="100">
                  <p id="brightnessValue">0.0</p>
                </div>

                <div id="editCont">
                  <p id="exposureVal">Exposure</p>
                  <input type="range" id="exposureSlider" class="sliders" min="-10" max="10" step="1" value="0">
                  <p id="expoValue">0.0</p>
                </div>

                <div id="editCont">
                  <p id="shadowVal">Shadows</p>
                  <input type="range" id="shadowSlider" class="sliders" min="-1" max="1" step="0.01" value="0">
                  <p id="shadowValue">0.0</p>
                </div>

                <div id="editCont">
                  <p id="lightVal">Lights</p>
                  <input type="range" id="lightSlider" class="sliders" min="-1" max="1" step="0.01" value="0">
                  <p id="lightValue">0.0</p>
                </div>

              </div>

              <hr>

              <div id="calibration">
                <h4>HSL</h4>
                <h5 id="calibTitle">Hue</h5>
                <div>
                  <div id="editCont">
                    <p id="redHVal">Red</p>
                    <input type="range" id="redHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="redHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="orangeHVal">Orange</p>
                    <input type="range" id="orangeHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="orangeHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="yellowHVal">Yellow</p>
                    <input type="range" id="yellowHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="yellowHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="greenHVal">Green</p>
                    <input type="range" id="greenHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="greenHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="aquaHVal">Aqua</p>
                    <input type="range" id="aquaHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="aquaHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="blueHVal">Blue</p>
                    <input type="range" id="blueHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="blueHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="purpleHVal">Purple</p>
                    <input type="range" id="purpleHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="purpleHValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="magentaHVal">Magenta</p>
                    <input type="range" id="magentaHSlider" class="sliders" min="-60" max="60" value="0">
                    <p id="magentaHValue">0.0</p>
                  </div>
                </div>
              </div>

              <hr>

              <div id="chanels">
                <h4>Chanels</h4>
                <div id="editCont">
                  <p id="redVal">Red</p>
                  <input type="range" id="redSlider" min="-10" max="10" step="0.01" value="0">
                  <p id="redValue">0.0</p>
                </div>

                <div id="editCont">
                  <p id="greenVal">Green</p>
                  <input type="range" id="greenSlider" min="-10" max="10" step="0.01" value="0">
                  <p id="greenValue">0.0</p>
                </div>

                <div id="editCont">
                  <p id="blueVal">Blue</p>
                  <input type="range" id="blueSlider" min="-10" max="10" step="0.01" value="0">
                  <p id="blueValue">0.0</p>
                </div>
              </div>

              <hr>

              <div id="calibration">
                <h4>Calibration</h4>
                <h5 id="calibTitle">Shadows</h5>
                <div id="editCont">
                  <p id="tintVal">Tint</p>
                  <input type="range" id="shadowsTint" class="sliders" min="-10" max="10" step="1" value="0">
                  <p id="tintValue">0.0</p>
                </div>

                <h5 id="calibTitle">Red Primary</h5>
                <div>
                  <div id="editCont">
                    <p id="redHueVal">Hue</p>
                    <input type="range" id="redHue" class="sliders" min="-1" max="1" step="0.01" value="0">
                    <p id="redHueValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="redSatVal">Saturation</p>
                    <input type="range" id="redSat" class="sliders" min="0" max="2" step="0.01" value="1">
                    <p id="redSatValue">0.0</p>
                  </div>
                </div>

                <h5 id="calibTitle">Green Primary</h5>
                <div>
                  <div id="editCont">
                    <p id="greenHueVal">Hue</p>
                    <input type="range" id="greenHue" class="sliders" min="-1" max="1" step="0.01" value="0">
                    <p id="greenHueValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="greenSatVal">Saturation</p>
                    <input type="range" id="greenSat" class="sliders" min="0" max="2" step="0.01" value="1">
                    <p id="greenSatValue">0.0</p>
                  </div>
                </div>

                <h5 id="calibTitle">Blue Primary </h5>
                <div>
                  <div id="editCont">
                    <p id="blueHueVal">Hue</p>
                    <input type="range" id="blueHue" class="sliders" min="-1" max="1" step="0.01" value="0">
                    <p id="blueHueValue">0.0</p>
                  </div>
                  <div id="editCont">
                    <p id="blueSatVal">Saturation</p>
                    <input type="range" id="blueSat" class="sliders" min="0" max="2" step="0.01" value="1">
                    <p id="blueSatValue">0.0</p>
                  </div>
                </div>

              </div>

              <hr>

          </div>

        </div>


      </div>

    </div>

  </div>

  <script>

    let base64Image = '';
    let image = document.getElementById('original')
    let res = document.getElementById('res')
    let load = document.getElementById('load')
    // const canvas       = document.getElementById("imageCanvas");
    // const ctx          = canvas.getContext("2d");
    const previewCanvas       = document.getElementById("previewCanvas");
    const previewCtx          = previewCanvas.getContext("2d");
    const fullCanvas       = document.getElementById("fullCanvas");
    const fullCtx          = fullCanvas.getContext("2d");
    const gammaCont = document.getElementById("gammaCont");

    const dialogWindow = document.getElementById('dialogWindow');


    // CHOOSE THE IMAGE
    // document.getElementById('fileInput').addEventListener('change', function (e) {
    //   const reader = new FileReader();
    //   reader.onload = function () {
    //     base64Image = reader.result;
    //     image.src = base64Image;
    //   };
    //   reader.readAsDataURL(e.target.files[0]);
    // });


    window.addEventListener('pywebviewready', () => {
      const image = document.getElementById('original');
      const fileInput = document.getElementById('fileInput');
      drawCurve()

      fileInput.addEventListener('change', async () => {
        dialogWindow.style.display = 'block';
        const file = fileInput.files[0];
        console.log('---------Filename----------', file.name);
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();
        const base64 = await arrayBufferToBase64(arrayBuffer);
        try {
          dialogWindow.innerText = `${file.name} is loading...`;
          const previewDataUrl = await window.pywebview.api.load_image_from_base64(base64, file.name);
          image.src = previewDataUrl;
          base64Image = previewDataUrl;
          dialogWindow.style.display = 'none';
        } catch (err) {
          dialogWindow.innerText = `Error ${err}`;
        }
      });

      function arrayBufferToBase64(buffer) {
        return new Promise((resolve, reject) => {
          const blob = new Blob([buffer], { type: 'application/octet-stream' });
          const reader = new FileReader();

          reader.onloadend = () => {
            const base64 = reader.result.split(',')[1]; // remove `data:...;base64,`
            resolve(base64);
          };

          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

  });



    // Black and white
    async function BW() {
      if (!base64Image) return alert("Please select an image first.");

      const result = await window.pywebview.api.process_image(base64Image);
      load.style.display = 'block';
      if (result.status === "success") {
        image.src = result.output_path + '?' + new Date().getTime(); // cache busting
        imgElem.src = result.output_path + '?' + new Date().getTime(); // cache copy busting
        load.style.display = 'none';
      } else {
        alert("Error: " + result.message);
        load.style.display = 'none';
      }
    }



    // REMOVE BACKGROUND
    async function removeBG() {
      if (!base64Image) return alert("Please select an image first.");

      const result = await window.pywebview.api.remove_bg(base64Image);
      if (result.status === "success") {
        image.src = result.output_path + '?' + new Date().getTime(); // cache busting
      } else {
        alert("Error: " + result.message);
      }
    }

    const gammaSlider = document.getElementById("gammaSlider");

    gammaSlider.addEventListener("input", () => {
      applyGammaCorrection(parseFloat(gammaSlider.value));
    });

    function applyGammaCorrection(gamma) {
      if (!image.src) return;
      res.style.filter = `brightness(${gamma}%)`;
      document.getElementById("brightnessValue").innerText = gamma;
    }


    const exposureSlider = document.getElementById("exposureSlider");
    const redHSlider = document.getElementById("redHSlider");
    const orangeHSlider = document.getElementById("orangeHSlider");
    const yellowHSlider = document.getElementById("yellowHSlider");
    const greenHSlider = document.getElementById("greenHSlider");
    const aquaHSlider = document.getElementById("aquaHSlider");
    const blueHSlider = document.getElementById("blueHSlider");
    const purpleHSlider = document.getElementById("purpleHSlider");
    const magentaHSlider = document.getElementById("magentaHSlider");
    const shadowSlider = document.getElementById("shadowSlider");
    const lightSlider  = document.getElementById("lightSlider");
    const redSlider = document.getElementById("redSlider");
    const greenSlider = document.getElementById("greenSlider");
    const blueSlider = document.getElementById("blueSlider");
    const shadowsTint = document.getElementById("shadowsTint");
    const redHue = document.getElementById("redHue");
    const redSat = document.getElementById("redSat");
    const greenHue = document.getElementById("greenHue");
    const greenSat = document.getElementById("greenSat");
    const blueHue = document.getElementById("blueHue");
    const blueSat = document.getElementById("blueSat");


    let originalImage = null; //new Image();
    let previewImage = null;
    let bufferImage = null;

    image.onload = () => {
      // Full-size canvas
      fullCanvas.width = image.naturalWidth;
      fullCanvas.height = image.naturalHeight;
      fullCtx.drawImage(image, 0, 0);

      originalImage = fullCtx.getImageData(0, 0, fullCanvas.width, fullCanvas.height);

      // Downscale for preview
      const previewSize = 1000;
      const scale = Math.min(previewSize / image.naturalWidth, previewSize / image.naturalHeight);

      previewCanvas.width = image.naturalWidth * scale;
      previewCanvas.height = image.naturalHeight * scale;

      previewCtx.drawImage(image, 0, 0, previewCanvas.width, previewCanvas.height);
      previewImage = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

      // bufferInit();

      // Draw initial preview
      applyChanges(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1);
      // applyChanges(0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1); // Default
    };


    // sRGB (0–1) to Linear RGB
    function sRGBToLinear(c) {
      c = c / 255;
      return (c <= 0.04045) ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }

    // Linear RGB to sRGB (0–1)
    function linearToSRGB(c) {
      return (c <= 0.0031308) ?
        12.92 * c :
        1.055 * Math.pow(c, 1 / 2.4) - 0.055;
    }


    let shadowStrength;
    let lightStrength;
    let exposureStrength;
    let redHStrength = 0;
    let orangeHStrength;
    let yellowHStrength;
    let greenHStrength;
    let aquaHStrength;
    let blueHStrength;
    let purpleHStrength;
    let magentaHStrength;
    let r;
    let g;
    let b;
    let shadowsTintStrenth;
    let redHueStrenth;
    let redSatStrength;
    let greenHueStrenth;
    let greenSatStrength;
    let blueHueStrenth;
    let blueSatStrength;
    let lut;


    [
      exposureSlider, 
      shadowSlider, 
      lightSlider, 
      redSlider, 
      greenSlider, 
      blueSlider,
      redHSlider,
      orangeHSlider,
      yellowHSlider,
      greenHSlider,
      aquaHSlider,
      blueHSlider,
      purpleHSlider,
      magentaHSlider,
      shadowsTint, 
      redHue, 
      redSat,
      greenHue, 
      greenSat, 
      blueHue, 
      blueSat
    ].forEach(slider => {
      slider.addEventListener("input", () => {
        shadowStrength = parseFloat(shadowSlider.value);
        document.getElementById("shadowValue").innerText = shadowStrength;
        lightStrength = parseFloat(lightSlider.value);
        document.getElementById("lightValue").innerText = lightStrength;
        exposureStrength = parseFloat(exposureSlider.value);
        document.getElementById("expoValue").innerText = exposureStrength;
        redHStrength = parseFloat(redHSlider.value);
        document.getElementById("redHValue").innerText = redHStrength;
        orangeHStrength = parseFloat(orangeHSlider.value);
        document.getElementById("orangeHValue").innerText = orangeHStrength;
        yellowHStrength = parseFloat(yellowHSlider.value);
        document.getElementById("yellowHValue").innerText = yellowHStrength;
        greenHStrength = parseFloat(greenHSlider.value);
        document.getElementById("greenHValue").innerText = greenHStrength;
        aquaHStrength = parseFloat(aquaHSlider.value);
        document.getElementById("aquaHValue").innerText = aquaHStrength;
        blueHStrength = parseFloat(blueHSlider.value);
        document.getElementById("blueHValue").innerText = blueHStrength;
        purpleHStrength = parseFloat(purpleHSlider.value);
        document.getElementById("purpleHValue").innerText = purpleHStrength;
        magentaHStrength = parseFloat(magentaHSlider.value);
        document.getElementById("redHValue").innerText = magentaHStrength;
        document.getElementById("redValue").innerText = r;
        r = parseFloat(redSlider.value);
        document.getElementById("redValue").innerText = r;
        g = parseFloat(greenSlider.value);
        document.getElementById("greenValue").innerText = g;
        b = parseFloat(blueSlider.value);
        document.getElementById("blueValue").innerText = b;
        shadowsTintStrenth = parseFloat(shadowsTint.value);
        document.getElementById("tintValue").innerText = shadowsTintStrenth;
        redHueStrenth = parseFloat(redHue.value);
        document.getElementById("redHueValue").innerText = redHueStrenth;
        redSatStrength = parseFloat(redSat.value);
        document.getElementById("redSatValue").innerText = redSatStrength;
        greenHueStrenth = parseFloat(greenHue.value);
        document.getElementById("greenHueValue").innerText = greenHueStrenth;
        greenSatStrength = parseFloat(greenSat.value);
        document.getElementById("greenSatValue").innerText = greenSatStrength;
        blueHueStrenth = parseFloat(blueHue.value); 
        document.getElementById("blueHueValue").innerText = blueHueStrenth;
        blueSatStrength = parseFloat(blueSat.value);
        document.getElementById("blueSatValue").innerText = blueSatStrength;
        applyChanges(
          exposureStrength, 
          shadowStrength, 
          lightStrength, 
          r,
          g,
          b,
          shadowsTintStrenth, 
          redHueStrenth, 
          orangeHStrength,
          yellowHStrength,
          greenHStrength,
          aquaHStrength,
          blueHStrength,
          purpleHStrength,
          magentaHStrength,
          redSatStrength,
          greenHueStrenth, 
          greenSatStrength, 
          blueHueStrenth, 
          blueSatStrength,
          // lut,
        )
      });
    });


    function applyChanges(
      exposureStrength, 
      shadowStrength, 
      lightStrength, 
      redShift,
      greenShift,
      blueShift,
      shadowsTintStrength, 
      redHueStrength, 
      orangeHStrength,
      yellowHStrength,
      greenHStrength,
      aquaHStrength,
      blueHStrength,
      purpleHStrength,
      magentaHStrength,
      redSatStrength,
      greenHueStrength, 
      greenSatStrength, 
      blueHueStrength, 
      blueSatStrength,
      // lut,
    ) {
      if (!previewImage) return;

      console.log('lut--------------', lut)
      console.log('redHueStrength--------------', redHueStrength)

      if (!lut) {
        lut = Array.from({ length: 256 }, (_, i) => i);  // ✅ use identity LUT if missing
        console.log('!lut--------------', lut)
      }

      const imageData = new ImageData(
        new Uint8ClampedArray(previewImage.data),
        previewImage.width,
        previewImage.height
      );

      const data = imageData.data;
      // bufferImage = imageData;

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i];
        let g = data[i + 1];
        let b = data[i + 2];

        // === CURVE LUT
        r = lut[r];     // R
        g = lut[g]; // G
        b = lut[b]; // B

        // Luma approximation (brightness)
        let brightness = 0.299 * r + 0.587 * g + 0.114 * b;

        // Exposure factor: commonly 2^EV (Exposure Value)
        const exposureFactor = Math.pow(2, exposureStrength); // e.g., EV +1 = 2x brighter
        // Convert to linear
        // let lr = sRGBToLinear(r);
        // let lg = sRGBToLinear(g);
        // let lb = sRGBToLinear(b);

        // Apply exposure in linear space
        r *= exposureFactor;
        g *= exposureFactor;
        b *= exposureFactor;

        // r = Math.min(255, r * redShift);
        // g = Math.min(255, g * greenShift);
        // b = Math.min(255, b * blueShift);

        if (brightness < 100) {
          const factor = 1 + shadowStrength * (1 - brightness / 100);
          r = Math.min(255, r * factor);
          g = Math.min(255, g * factor);
          b = Math.min(255, b * factor);
        }

        if (brightness > 155) {
          const factor = 1 + lightStrength  * ((brightness - 155) / 100);
          r = Math.min(255, Math.max(0, r * factor));
          g = Math.min(255, Math.max(0, g * factor));
          b = Math.min(255, Math.max(0, b * factor)); 
        }

        // === Shadows Tint (Green ↔ Magenta)
        // r = Math.min(255, g * (1 + shadowsTintStrength));
        // g = Math.min(255, r * (1 - shadowsTintStrength / 2));
        // b = Math.min(255, b * (1 - shadowsTintStrength / 2));
        // if (brightness < 100) {
        //   lg = lg * (1 + shadowsTintStrength);
        //   lr = lr * (1 - shadowsTintStrength / 2);
        //   lb = lb * (1 - shadowsTintStrength / 2);
        // }

        // === Red Primary Hue + Sat (affects reds more)
        // if (r > g && r > b) {
          r += redHueStrength * (g - b);
          r *= redSatStrength;
        // }

        // === Green Primary Hue + Sat (affects greens more)
        // if (g > r && g > b) {
          g += greenHueStrength * (b - r);
          g *= greenSatStrength;
        // }

        // === Blue Primary Hue + Sat (affects blues more)
        // if (b > r && b > g) {
          b += blueHueStrength * (r - g);
          b *= blueSatStrength;
        // }


        // === COLOR CORECTION == //

        const hslColorBands = {
          red:     { min: 345, max: 15 },
          orange:  { min: 15,  max: 45 },
          yellow:  { min: 45,  max: 70 },
          green:   { min: 70,  max: 170 },
          aqua:    { min: 170, max: 200 },
          blue:    { min: 200, max: 260 },
          purple:  { min: 260, max: 290 },
          magenta: { min: 290, max: 345 },
        };

        // const adjustments = {
        //   red:     { hue: redHStrength, sat: 1, lum: 0 },
        //   orange:  { hue: orangeHStrength,  sat: 1, lum: 0 },
        //   yellow:  { hue: yellowHStrength, sat: 1, lum: 0 },
        //   green:   { hue: greenHStrength, sat: 1, lum: 0 },
        //   aqua:    { hue: aquaHStrength, sat: 1, lum: 0 },
        //   blue:    { hue: blueHStrength, sat: 1, lum: 0 },
        //   purple:  { hue: purpleHStrength, sat: 1, lum: 0 },
        //   magenta: { hue: magentaHStrength, sat: 1, lum: 0 },
        // };

        const adjustments = {
          red:     { hue: redHStrength, sat: 0, lum: 0 },
          orange:  { hue: orangeHStrength, sat: 0, lum: 0 },
          yellow:  { hue: yellowHStrength, sat: 0, lum: 0 },
          green:   { hue: greenHStrength, sat: 0, lum: 0 },
          aqua:    { hue: aquaHStrength, sat: 0, lum: 0 },
          blue:    { hue: blueHStrength, sat: 0, lum: 0 },
          purple:  { hue: purpleHStrength, sat: 0, lum: 0 },
          magenta: { hue: magentaHStrength, sat: 0, lum: 0 },
        };



        let [h, s, l] = rgbToHsl(r, g, b);

        for (const [band, {min, max}] of Object.entries(hslColorBands)) {
          const adj = adjustments[band];
          if (adj) {
            const inRange = (min < max)
              ? h >= min && h < max
              : h >= min || h < max;

            if (inRange) {
              h = (h + adj.hue) % 360;
              s = Math.min(1, Math.max(0, s + adj.sat));
              l = Math.min(1, Math.max(0, l + adj.lum));
            }
          }
        }

        const [newR, newG, newB] = hslToRgb(h, s, l);
        r = newR;
        g = newG;
        b = newB;

        data[i] = Math.min(255, Math.max(0, r));
        data[i + 1] = Math.min(255, Math.max(0, g));
        data[i + 2] = Math.min(255, Math.max(0, b));
        // Convert back to sRGB
        // data[i]     = Math.min(255, linearToSRGB(lr) * 255);
        // data[i + 1] = Math.min(255, linearToSRGB(lg) * 255);
        // data[i + 2] = Math.min(255, linearToSRGB(lb) * 255);

      }

      previewCtx.putImageData(imageData, 0, 0);
      res.src = previewCanvas.toDataURL();
    }



    let isDragging = false;
    let offsetX, offsetY;


    gammaCont.addEventListener("mousedown", (e) => {
        if (e.target.tagName === "INPUT") return;
        isDragging = true;
        offsetX = e.clientX - gammaCont.getBoundingClientRect().left;
        offsetY = e.clientY - gammaCont.getBoundingClientRect().top;
        gammaCont.style.cursor = "grabbing";
    });

    document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;

        gammaCont.style.left = `${e.clientX - offsetX}px`;
        gammaCont.style.top = `${e.clientY - offsetY}px`;
    });

    document.addEventListener("mouseup", () => {
        isDragging = false;
        gammaCont.style.cursor = "grab";
    });


    // CURVE LOGIC
    let curvePoints = [
    { x: 0, y: 0 },
    { x: 64, y: 64 },
    { x: 128, y: 128 },
    { x: 192, y: 192 },
    { x: 255, y: 255 }
  ];

  function getCurveLUT(points) {
    lut = new Uint8ClampedArray(256);
    for (let i = 0; i < 256; i++) {
      lut[i] = applyCurve(i, points);
    }
    return lut;
  }

  function applyCurve(value, points) {
    // Linear interpolation between points
    for (let i = 0; i < points.length - 1; i++) {
      const p1 = points[i];
      const p2 = points[i + 1];
      if (value >= p1.x && value <= p2.x) {
        const ratio = (value - p1.x) / (p2.x - p1.x);
        return Math.round(p1.y + ratio * (p2.y - p1.y));
      }
    }
    return value; // fallback
  }

  const canvas = document.getElementById("curveCanvas");
  const ctx = canvas.getContext("2d");
  const pointRadius = 5;

  // canvas.addEventListener("mousedown", onMouseDown);
  canvas.addEventListener("mousedown", e => {
    e.stopPropagation();  // ✅ prevent canvas toggle behavior
    onMouseDown(e);
  });
  canvas.addEventListener("mousemove", e => {
    if (dragging !== null) {
      onMouseMove(e);  // this should update the curve + image only when dragging
    }
  });


  // canvas.addEventListener("mousemove", onMouseMove);
  canvas.addEventListener("mouseup", () => dragging = null);
  canvas.addEventListener("mouseleave", () => dragging = null);

  let dragging = null;

  // function openCurve() {
  //   canvas.style.display = canvas.style.display === "block" ? "none" : "block";
  //   drawCurve();
  // }

  function drawCurve() {
    canvas.style.cursor = "crosshair";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "white";
    ctx.beginPath();
    for (let i = 0; i < curvePoints.length; i++) {
      const p = curvePoints[i];
      const px = p.x * canvas.width / 255;
      const py = canvas.height - p.y * canvas.height / 255;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Draw points
    curvePoints.forEach((p, i) => {
      const px = p.x * canvas.width / 255;
      const py = canvas.height - p.y * canvas.height / 255;
      ctx.beginPath();
      ctx.arc(px, py, pointRadius, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
    });
  }

  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  function onMouseDown(e) {
    const pos = getMousePos(e);
    const cx = pos.x * 255 / canvas.width;
    const cy = (canvas.height - pos.y) * 255 / canvas.height;

    for (let i = 0; i < curvePoints.length; i++) {
      const p = curvePoints[i];
      const px = p.x * canvas.width / 255;
      const py = canvas.height - p.y * canvas.height / 255;
      const dx = pos.x - px;
      const dy = pos.y - py;
      if (dx * dx + dy * dy < pointRadius * pointRadius * 4) {
        dragging = i;
        break;
      }
    }
  }

  function onMouseMove(e) {
    if (dragging === null) return;
    const pos = getMousePos(e);
    const x = Math.max(0, Math.min(255, pos.x * 255 / canvas.width));
    const y = Math.max(0, Math.min(255, (canvas.height - pos.y) * 255 / canvas.height));

    curvePoints[dragging].x = x;
    curvePoints[dragging].y = y;

    curvePoints.sort((a, b) => a.x - b.x); // Maintain order
    drawCurve();
    lut = getCurveLUT(curvePoints);
    // console.log('onMouseMove----------', lut)
      applyChanges(
        parseFloat(shadowSlider.value),
        parseFloat(lightSlider.value),
        parseFloat(exposureSlider.value),
        parseFloat(redSlider.value),
        parseFloat(greenSlider.value),
        parseFloat(blueSlider.value),
        parseFloat(shadowsTint.value),
        parseFloat(redHue.value),
        parseFloat(redSat.value),
        parseFloat(greenHue.value),
        parseFloat(greenSat.value),
        parseFloat(blueHue.value),
        parseFloat(blueSat.value),
      // lut,
    ) 
    // applyToneCurveToImage();
    
  };


  function applyToneCurveToImage() {
    if (!previewImage) return;

    console.log('applyToneCurveToImage------------', lut)

    const imageData = new ImageData(
      new Uint8ClampedArray(previewImage.data),
      previewImage.width,
      previewImage.height
    );

    const data =  imageData.data;

    for (let i = 0; i < data.length; i += 4) {
      data[i]     = lut[data[i]];     // R
      data[i + 1] = lut[data[i + 1]]; // G
      data[i + 2] = lut[data[i + 2]]; // B
    }

    bufferImage.data = data
    previewCtx.putImageData(imageData, 0, 0);
    res.src = previewCanvas.toDataURL();

  }


  // ============ COLOR CORRECTION ============ //

  function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0; // achromatic
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch(max){
        case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
        case g: h = ((b - r) / d + 2); break;
        case b: h = ((r - g) / d + 4); break;
      }
      h *= 60;
    }

    return [h, s, l];
  }

function hslToRgb(h, s, l) {
  let r, g, b;
  h = h % 360;
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      t = (t < 0) ? t + 1 : (t > 1) ? t - 1 : t;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    h /= 360;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [r * 255, g * 255, b * 255];
}





  </script>
  <script src="./js/gamma.js"></script>
</body>
</html>
